(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{622:function(t,a,s){"use strict";s.r(a);var r=s(5),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第一章、权衡的艺术"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一章、权衡的艺术"}},[t._v("#")]),t._v(" "),s("strong",[t._v("第一章、权衡的艺术")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("框架的设计里到处都体现了权衡的艺术\n")])])]),s("h2",{attrs:{id:"命令式和声明式的差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命令式和声明式的差异"}},[t._v("#")]),t._v(" 命令式和声明式的差异：")]),t._v(" "),s("h4",{attrs:{id:"结论-声明式代码的性能不优于命令式代码的性能"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结论-声明式代码的性能不优于命令式代码的性能"}},[t._v("#")]),t._v(" 结论：声明式代码的性能不优于命令式代码的性能")]),t._v(" "),s("p",[t._v("理论上：命令式代码会比生命氏代码做到最优的更新性能 但声明式代码的可维护性更强")]),t._v(" "),s("p",[t._v("声明式代码提升维护性的同时，性能会有一定的损失，而框架要做的就是：在保持可维护性的同时，将性能损失最小化")]),t._v(" "),s("h4",{attrs:{id:"声明式代码和命令式代码消耗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明式代码和命令式代码消耗"}},[t._v("#")]),t._v(" 声明式代码和命令式代码消耗")]),t._v(" "),s("p",[t._v("我们假设直接修改的新能消耗定义为A，把找出差异的性能消耗定义为B 那么公式如下：")]),t._v(" "),s("ul",[s("li",[t._v("命令式代码的更新性能消耗=A")]),t._v(" "),s("li",[t._v("声明式代码的更新性能消耗=B+A")])]),t._v(" "),s("h4",{attrs:{id:"虚拟dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),s("ul",[s("li",[t._v("虚拟DOM，是为了最小化找出差异这一步的性能消耗而诞生的")]),t._v(" "),s("li",[t._v("虚拟DOM的更新技术性能理论上不会比原声JavaScript操作DOM更高")])]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ul",[s("li",[t._v("命令式关注过程,声明式关注结果")]),t._v(" "),s("li",[t._v("命令式在理论上可以做到极致优化 ，但是用户要承受巨大的心智负担")]),t._v(" "),s("li",[t._v("声明式能够有效减轻用户的心智负担，但是性能有一定损失 框架设计者要想办法尽量将性能损耗最小化")]),t._v(" "),s("li",[t._v("声明式的更新性能消耗=找出差异的性能消耗+直接修改的性能消耗")])])])}),[],!1,null,null,null);a.default=v.exports}}]);