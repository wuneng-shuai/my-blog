(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{625:function(e,t,n){"use strict";n.r(t);var a=n(5),c=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("4.1 副作用函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" function effect() {\n    document.body.innerText='hello vue3'\n  }\n  effect()\n")])])]),n("p",[e._v("effect函数设置了body的内容，但除了effect函数外的任何函数都可以读取或设置body的文本内容，所以，effect函数的执行会直接或间接的影响其他函数的执行，这时我们就会说effect函数产生了副作用。")]),e._v(" "),n("p",[e._v("4.2响应式数据")]),e._v(" "),n("p",[e._v("假设我们在一个副作用函数中读取了某个对象的属性")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" const obj={text:\"hello word\"}\n  function effect() {\n    // effect函数的执行会读取obj.text\n    document.body.innerText=obj.text\n  }\n  obj.text='hello vue3' //修改obj.text的值，同时希望副作用函数会重新执行\n")])])]),n("p",[e._v("当我们修改了obj.text的值后，我们希望当值变化话，effect函数会自动重新执行，如果能实现这个目标，那么对象obj就是响应式数据。")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("4.2响应式数据的基本实现")]),e._v(" "),n("ul",[n("li",[e._v("effect函数执行时，会触发obj.text的读取操作")]),e._v(" "),n("li",[e._v("修改obj.text的值时，会触发字段obj.text的设置操作")]),e._v(" "),n("li",[e._v("那么当我们读取obj.tetx时，我们把副作用函数effect函数存储起来")]),e._v(" "),n("li",[e._v("当我们设置obj.text时，再把副作用函数effect函数取出来执行，这样便完成了响应式")])]),e._v(" "),n("p",[e._v("vue3.js采用代理对象proxy来实现响应式数据")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  // 副作用函数\n  function effect () {\n    // effect函数的执行会读取obj.text\n    document.body.innerText = obj.text\n  }\n  // 存储副作用函数\n  const bucket = new Set()\n  const data = { text: 'hello word' }\n  const obj = new Proxy(data, {\n    get (target, key){\n      bucket.add(effect)\n      return target[key]\n    },\n    set (target, key,newVal){\n      bucket.forEach(fn => fn());\n      return true\n    }\n  })\n  // 执行副作用函数\n  effect()\n  // 一秒后修改响应式数据\n  setTimeout(() =>{\n    obj.text = '悟能'\n  }, 1000)\n")])])]),n("p",[e._v("首先上面代码中，我们创建了一个存储副作用函数的存储痛bucket，他是set类型。接着我们定义了原始数据data，obj是原属数据的代理对象。我们分别对他设置了get和set拦截函数。从而读取和设置操作")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("4.3 完善的响应式系统")]),e._v(" "),n("p",[e._v("4.2中我们写死了副作用函数的名字为effect，无法修改，修改会导致函数不能正确的执行，而我们希望的是函数哪怕是一个匿名函数，也可以正确的被执行。那么我来修改上面的代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" // 用一个全局变量存储被注册的副作用函数\n  let activeEffect\n  // effect函数用于注册副作用函数\n  function effect (fn) {\n    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect\n    activeEffect = fn\n    fn()\n  }\n  // 存储副作用函数\n  const bucket = new Set()\n  const data = { text: 'hello word' }\n  const obj = new Proxy(data, {\n    get (target, key){\n      // 将activeEffect 中存储的副作用函数收集到桶中\n   if(activeEffect){\n    bucket.add(activeEffect)\n   }\n      return target[key]\n    },\n    set (target, key, newVal){\n      console.log(target,key,newVal);\n      target[key]=newVal\n      bucket.forEach(fn => fn());\n      return true\n    }\n  })\n  // 使用effect函数\n  effect(() => { document.body.innerText = obj.text })\n  // 一秒后修改响应式数据\n  setTimeout(() =>\n  {\n    obj.text = '悟能'\n  }, 1000)\n")])])]),n("p",[e._v("如上代码展示我们已经解决了副作用函数名称的问题，但是我们还没有在副作用函数与被操作的目标字段之间建立联系，也就是说即使修改了 obj 上面的其他字段，副作用函数也会被执行，需要将 "),n("code",[e._v("obj.text")]),e._v("字段和调用过它的副作用函数联系起来。")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("4.4 将副作用函数与被操作的目标字段之间建立联系")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\n  // 用一个全局变量存储被注册的副作用函数\n  let activeEffect\n  // effect函数用于注册副作用函数\n  function effect (fn) {\n    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect\n    activeEffect = fn\n    fn()\n  }\n  const data = { text: 'hello word' }\n  // 存储副作用函数\n  const bucket = new WeakMap()\n  const obj = new Proxy(data, {\n    get (target, key){\n      // 没有activeEffect 直接return\n      if(!activeEffect) return target[key]\n      // 根据target从“桶”中取得depsMap 它也是一个map类型: key=>effects\n      let depsMap=bucket.get(target)\n      console.log(depsMap,'1');\n      if(!depsMap){\n        bucket.set(target, (depsMap = new Map()))\n      }\n      console.log(depsMap,'2');\n      // 在根据key从depsMap中取得deps 他是一个set类型\n      // 里面存储着所有与当前key 相关联的副作用函数：effects\n      let deps = depsMap.get(key) \n      console.log(deps);\n      // 如果deps不存在 同样我们要新建立一个Set并与key关联\n      if (!deps) {\n      depsMap.set(key, (deps = new Set()))//这样我们就与目标字段建立了联系\n     }\n    //  最后我们将当前激活的副作用函数添加到存储痛里\n    deps.add(activeEffect)\n    // 返回属性值\n    return target[key]\n  \n    },\n    set (target, key, newVal){\n      target[key]=newVal\n      // 根据target 从桶中取得 depsMap 他是key--\x3eeffects\n      const depsMap=bucket.get(target)\n      if(!depsMap) return\n      const effects=depsMap.get(key)\n      console.log(effects);\n      effects && effects.forEach(fn => fn() )\n    }\n  })\n  // 使用effect函数\n  effect(() => { document.body.innerText = obj.text })\n  // 一秒后修改响应式数据\n  setTimeout(() =>{\n    console.log(1);\n    obj.text = '悟能'\n     // 修改不相关的值副作用函数不会执行\n    // obj.asd = 'hello vue3'\n  }, 1000)\n\n")])])]),n("p",[e._v("4.5 WeakMap和Map的区别")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  const map = new Map()\n  const weakMap = new WeakMap()\n    (function ()  {\n      const foo = { foo: 1 }\n      const bar = { bar: 2 }\n      map.set(foo, 1)\n      weakMap.set(bar, 2)\n    })()\n  \n")])])]),n("p",[e._v("由于WeakMap的key是弱引用，他不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就回吧对象bar从内存中移除，我们也就无法获取weakMap的key值，也就无法通过weakMap取得对象bar")]),e._v(" "),n("p",[e._v("简单来说WeakMap的key是弱引用，不影响垃圾回收机器的工作，根据这个特性，如果我们使用Map，那么即使用户侧的代码对target没有任何引用，但target也不会被回收，最终会导致内存溢出。")]),e._v(" "),n("p",[e._v("根据WeakMap的特性，我们对上面代码进行封装处理，读取属性值时，我们直接在get拦截器函数里编写副作用函数的这部分逻辑单独封装到一个track函数里。把触发副作用函数重新执行的逻辑封装到trigger函数中：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  // 用一个全局变量存储被注册的副作用函数\n  let activeEffect\n  // effect函数用于注册副作用函数\n  function effect (fn) {\n    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect\n    activeEffect = fn\n    fn()\n  }\n  const data = { text: 'hello word' }\n  // 存储副作用函数\n  const bucket = new WeakMap()\n  const obj = new Proxy(data, {\n    get (target, key){\n      track(target, key)\n      return target[key]\n\n    },\n    set (target, key, newVal){\n      target[key] = newVal\n      trigger(target,key)\n    }\n  })\n\n  function track (target, key){\n    // 没有activeEffect 直接return\n    if (!activeEffect) return target[key]\n    // 根据target从“桶”中取得depsMap 它也是一个map类型: key=>effects\n    let depsMap = bucket.get(target)\n    if (!depsMap) {\n      bucket.set(target, (depsMap = new Map()))\n    }\n    // 在根据key从depsMap中取得deps 他是一个set类型\n    // 里面存储着所有与当前key 相关联的副作用函数：effects\n    let deps = depsMap.get(key)\n    console.log(deps);\n    // 如果deps不存在 同样我们要新建立一个Set并与key关联\n    if (!deps) {\n      depsMap.set(key, (deps = new Set()))//这样我们就与目标字段建立了联系\n    }\n    //  最后我们将当前激活的副作用函数添加到存储痛里\n    deps.add(activeEffect)\n  }\n  function trigger(target,key) {\n     // 根据target 从桶中取得 depsMap 他是key--\x3eeffects\n     const depsMap = bucket.get(target)\n      if (!depsMap) return\n      const effects = depsMap.get(key)\n      effects && effects.forEach(fn => fn())\n  }\n\n  // 使用effect函数\n  effect(() => { document.body.innerText = obj.text })\n  // 一秒后修改响应式数据\n  setTimeout(() =>{\n    console.log(1);\n    obj.text = '悟能'\n  }, 1000)\n\n")])])])])}),[],!1,null,null,null);t.default=c.exports}}]);