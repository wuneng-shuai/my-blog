---
title: 第四章、响应系统的作用与实现
cover: 
date: 2022-05-18
tags:
    - vue.js
categories:
    - 《vue.js设计与实现》
---
4.1 副作用函数

```
 function effect() {
    document.body.innerText='hello vue3'
  }
  effect()
```

effect函数设置了body的内容，但除了effect函数外的任何函数都可以读取或设置body的文本内容，所以，effect函数的执行会直接或间接的影响其他函数的执行，这时我们就会说effect函数产生了副作用。

4.2响应式数据

假设我们在一个副作用函数中读取了某个对象的属性

```
 const obj={text:"hello word"}
  function effect() {
    // effect函数的执行会读取obj.text
    document.body.innerText=obj.text
  }
  obj.text='hello vue3' //修改obj.text的值，同时希望副作用函数会重新执行
```

当我们修改了obj.text的值后，我们希望当值变化话，effect函数会自动重新执行，如果能实现这个目标，那么对象obj就是响应式数据。

---

4.2响应式数据的基本实现

* effect函数执行时，会触发obj.text的读取操作
* 修改obj.text的值时，会触发字段obj.text的设置操作
* 那么当我们读取obj.tetx时，我们把副作用函数effect函数存储起来
* 当我们设置obj.text时，再把副作用函数effect函数取出来执行，这样便完成了响应式

vue3.js采用代理对象proxy来实现响应式数据

```
  // 副作用函数
  function effect () {
    // effect函数的执行会读取obj.text
    document.body.innerText = obj.text
  }
  // 存储副作用函数
  const bucket = new Set()
  const data = { text: 'hello word' }
  const obj = new Proxy(data, {
    get (target, key){
      bucket.add(effect)
      return target[key]
    },
    set (target, key,newVal){
      bucket.forEach(fn => fn());
      return true
    }
  })
  // 执行副作用函数
  effect()
  // 一秒后修改响应式数据
  setTimeout(() =>{
    obj.text = '悟能'
  }, 1000)
```

首先上面代码中，我们创建了一个存储副作用函数的存储痛bucket，他是set类型。接着我们定义了原始数据data，obj是原属数据的代理对象。我们分别对他设置了get和set拦截函数。从而读取和设置操作

---

4.3 完善的响应式系统

4.2中我们写死了副作用函数的名字为effect，无法修改，修改会导致函数不能正确的执行，而我们希望的是函数哪怕是一个匿名函数，也可以正确的被执行。那么我来修改上面的代码

```
 // 用一个全局变量存储被注册的副作用函数
  let activeEffect
  // effect函数用于注册副作用函数
  function effect (fn) {
    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect
    activeEffect = fn
    fn()
  }
  // 存储副作用函数
  const bucket = new Set()
  const data = { text: 'hello word' }
  const obj = new Proxy(data, {
    get (target, key){
      // 将activeEffect 中存储的副作用函数收集到桶中
   if(activeEffect){
    bucket.add(activeEffect)
   }
      return target[key]
    },
    set (target, key, newVal){
      console.log(target,key,newVal);
      target[key]=newVal
      bucket.forEach(fn => fn());
      return true
    }
  })
  // 使用effect函数
  effect(() => { document.body.innerText = obj.text })
  // 一秒后修改响应式数据
  setTimeout(() =>
  {
    obj.text = '悟能'
  }, 1000)
```

如上代码展示我们已经解决了副作用函数名称的问题，但是我们还没有在副作用函数与被操作的目标字段之间建立联系，也就是说即使修改了 obj 上面的其他字段，副作用函数也会被执行，需要将 `obj.text`字段和调用过它的副作用函数联系起来。

---

4.4 将副作用函数与被操作的目标字段之间建立联系

```

  // 用一个全局变量存储被注册的副作用函数
  let activeEffect
  // effect函数用于注册副作用函数
  function effect (fn) {
    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect
    activeEffect = fn
    fn()
  }
  const data = { text: 'hello word' }
  // 存储副作用函数
  const bucket = new WeakMap()
  const obj = new Proxy(data, {
    get (target, key){
      // 没有activeEffect 直接return
      if(!activeEffect) return target[key]
      // 根据target从“桶”中取得depsMap 它也是一个map类型: key=>effects
      let depsMap=bucket.get(target)
      console.log(depsMap,'1');
      if(!depsMap){
        bucket.set(target, (depsMap = new Map()))
      }
      console.log(depsMap,'2');
      // 在根据key从depsMap中取得deps 他是一个set类型
      // 里面存储着所有与当前key 相关联的副作用函数：effects
      let deps = depsMap.get(key) 
      console.log(deps);
      // 如果deps不存在 同样我们要新建立一个Set并与key关联
      if (!deps) {
      depsMap.set(key, (deps = new Set()))//这样我们就与目标字段建立了联系
     }
    //  最后我们将当前激活的副作用函数添加到存储痛里
    deps.add(activeEffect)
    // 返回属性值
    return target[key]
  
    },
    set (target, key, newVal){
      target[key]=newVal
      // 根据target 从桶中取得 depsMap 他是key-->effects
      const depsMap=bucket.get(target)
      if(!depsMap) return
      const effects=depsMap.get(key)
      console.log(effects);
      effects && effects.forEach(fn => fn() )
    }
  })
  // 使用effect函数
  effect(() => { document.body.innerText = obj.text })
  // 一秒后修改响应式数据
  setTimeout(() =>{
    console.log(1);
    obj.text = '悟能'
     // 修改不相关的值副作用函数不会执行
    // obj.asd = 'hello vue3'
  }, 1000)

```

4.5 WeakMap和Map的区别

```
  const map = new Map()
  const weakMap = new WeakMap()
    (function ()  {
      const foo = { foo: 1 }
      const bar = { bar: 2 }
      map.set(foo, 1)
      weakMap.set(bar, 2)
    })()
  
```

由于WeakMap的key是弱引用，他不影响垃圾回收器的工作，所以一旦表达式执行完毕，垃圾回收器就回吧对象bar从内存中移除，我们也就无法获取weakMap的key值，也就无法通过weakMap取得对象bar

简单来说WeakMap的key是弱引用，不影响垃圾回收机器的工作，根据这个特性，如果我们使用Map，那么即使用户侧的代码对target没有任何引用，但target也不会被回收，最终会导致内存溢出。

根据WeakMap的特性，我们对上面代码进行封装处理，读取属性值时，我们直接在get拦截器函数里编写副作用函数的这部分逻辑单独封装到一个track函数里。把触发副作用函数重新执行的逻辑封装到trigger函数中：

```
  // 用一个全局变量存储被注册的副作用函数
  let activeEffect
  // effect函数用于注册副作用函数
  function effect (fn) {
    // 当我们调用effect注册副作用函数时，将副作用函数fn复制给activeEffect
    activeEffect = fn
    fn()
  }
  const data = { text: 'hello word' }
  // 存储副作用函数
  const bucket = new WeakMap()
  const obj = new Proxy(data, {
    get (target, key){
      track(target, key)
      return target[key]

    },
    set (target, key, newVal){
      target[key] = newVal
      trigger(target,key)
    }
  })

  function track (target, key){
    // 没有activeEffect 直接return
    if (!activeEffect) return target[key]
    // 根据target从“桶”中取得depsMap 它也是一个map类型: key=>effects
    let depsMap = bucket.get(target)
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()))
    }
    // 在根据key从depsMap中取得deps 他是一个set类型
    // 里面存储着所有与当前key 相关联的副作用函数：effects
    let deps = depsMap.get(key)
    console.log(deps);
    // 如果deps不存在 同样我们要新建立一个Set并与key关联
    if (!deps) {
      depsMap.set(key, (deps = new Set()))//这样我们就与目标字段建立了联系
    }
    //  最后我们将当前激活的副作用函数添加到存储痛里
    deps.add(activeEffect)
  }
  function trigger(target,key) {
     // 根据target 从桶中取得 depsMap 他是key-->effects
     const depsMap = bucket.get(target)
      if (!depsMap) return
      const effects = depsMap.get(key)
      effects && effects.forEach(fn => fn())
  }

  // 使用effect函数
  effect(() => { document.body.innerText = obj.text })
  // 一秒后修改响应式数据
  setTimeout(() =>{
    console.log(1);
    obj.text = '悟能'
  }, 1000)

```
